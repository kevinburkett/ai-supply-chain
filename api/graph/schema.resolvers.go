package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.52

import (
	db "ai-supply-chain/db/sqlc"
	"api/graph/model"
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/google/uuid"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("database not configured")
	}

	prodID, err := uuid.Parse(input.ProductID)
	if err != nil {
		return nil, err
	}

	// fetch product for response
	product, err := r.DB.GetProduct(ctx, prodID)
	if err != nil {
		return nil, err
	}

	// predict delay risk using external AI service
	aiURL := os.Getenv("AI_SERVICE_URL")
	if aiURL == "" {
		aiURL = "http://ai-service:8080"
	}

	reqBody := struct {
		ProductID string `json:"product_id"`
		Qty       int    `json:"qty"`
	}{ProductID: input.ProductID, Qty: input.Qty}

	var risk float64
	data, err := json.Marshal(reqBody)
	if err == nil {
		resp, err := http.Post(aiURL+"/predict_delay", "application/json", bytes.NewBuffer(data))
		if err == nil {
			defer resp.Body.Close()
			var res struct {
				DelayRisk float64 `json:"delay_risk"`
			}
			if err = json.NewDecoder(resp.Body).Decode(&res); err == nil {
				risk = res.DelayRisk
			}
		}
	}

	// create order record
	orderParams := db.CreateOrderParams{
		ID:        uuid.New(),
		ProductID: uuid.NullUUID{UUID: prodID, Valid: true},
		Quantity:  int32(input.Qty),
		Status:    "PENDING",
		DelayRisk: sql.NullFloat64{Float64: risk, Valid: true},
	}

	ord, err := r.DB.CreateOrder(ctx, orderParams)
	if err != nil {
		return nil, err
	}

	// build GraphQL model
	return &model.Order{
		ID:             ord.ID.String(),
		Product:        &model.Product{ID: product.ID.String(), Name: product.Name},
		Qty:            int(ord.Quantity),
		Status:         ord.Status,
		CreatedAt:      ord.CreatedAt.Time.Format(time.RFC3339),
		DelayRiskScore: ord.DelayRisk.Float64,
	}, nil
}

// UpdateStatus is the resolver for the updateStatus field.
func (r *mutationResolver) UpdateStatus(ctx context.Context, id string, status string) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: UpdateStatus - updateStatus"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("database not configured")
	}

	orderID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	ord, err := r.DB.GetOrder(ctx, orderID)
	if err != nil {
		return nil, err
	}

	product, err := r.DB.GetProduct(ctx, ord.ProductID.UUID)
	if err != nil {
		return nil, err
	}

	return &model.Order{
		ID:             ord.ID.String(),
		Product:        &model.Product{ID: product.ID.String(), Name: product.Name},
		Qty:            int(ord.Quantity),
		Status:         ord.Status,
		CreatedAt:      ord.CreatedAt.Time.Format(time.RFC3339),
		DelayRiskScore: ord.DelayRisk.Float64,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
